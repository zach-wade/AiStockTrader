# File: risk_management/real_time/live_risk_monitor.py

"""
Real-time Risk Monitoring System for Live Trading Integration

This module provides comprehensive real-time risk monitoring that integrates with
the trading engine to provide live position tracking, P&L monitoring, and
automated risk limit enforcement.

Key Features:
- Real-time portfolio value tracking
- Live P&L calculation and monitoring  
- Dynamic position sizing based on current portfolio state
- Portfolio exposure limits enforcement
- Pre-trade risk validation with order blocking
- VaR-based position sizing
- Circuit breaker integration
- Real-time risk alerts and dashboard updates
"""

import asyncio
import logging
from datetime import datetime, timezone, timedelta
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any, Callable, Tuple, Union
from decimal import Decimal
import numpy as np
import pandas as pd

# Import existing risk management components
from main.risk_management.pre_trade.unified_limit_checker import (
    UnifiedLimitChecker, LimitDefinition, LimitType, LimitScope, 
    ComparisonOperator, LimitAction, ViolationSeverity, LimitCheckResult
)
from main.risk_management.real_time.circuit_breaker import (
    CircuitBreakerFacade, MarketConditions, BreakerEvent, BreakerType, BreakerStatus
)
from main.feature_pipeline.calculators.risk import (
    VaRCalculator, RiskConfig, RiskMetricsFacade
)
from main.risk_management.types import RiskAlert, RiskAlertLevel
from main.models.common import OrderSide

# Import trading engine components
from main.trading_engine.core.position_manager import (
    PositionManager as UnifiedPositionManager, Position
)
from main.trading_engine.core.position_events import (
    PositionEvent, PositionEventType
)

# Import cache components
from main.utils.cache import MemoryBackend
from main.utils.cache import CacheType

logger = logging.getLogger(__name__)


class RiskProfileType(Enum):
    """Risk profile types for different trading modes."""
    PAPER_TRADING = "paper_trading"
    CONSERVATIVE_LIVE = "conservative_live"
    MODERATE_LIVE = "moderate_live"
    AGGRESSIVE_LIVE = "aggressive_live"


class RiskDecisionType(Enum):
    """Types of risk decisions."""
    ALLOW_TRADE = "allow_trade"
    BLOCK_TRADE = "block_trade"
    REDUCE_POSITION = "reduce_position"
    ALERT_ONLY = "alert_only"
    EMERGENCY_HALT = "emergency_halt"


@dataclass
class RiskMonitorConfig:
    """Configuration for the live risk monitor."""
    check_interval_seconds: int = 5
    var_calculation_interval: int = 60
    max_portfolio_risk: float = 0.02
    enable_circuit_breakers: bool = True
    enable_var_sizing: bool = True
    alert_on_limit_breach: bool = True


@dataclass
class MonitoringAlert:
    """Alert generated by the risk monitoring system."""
    timestamp: datetime
    level: RiskAlertLevel
    source: str
    message: str
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class RiskDecision:
    """Risk management decision with detailed reasoning."""
    
    decision_id: str
    decision_type: RiskDecisionType
    allowed: bool
    
    # Context
    symbol: str
    side: OrderSide
    quantity: Decimal
    price: Decimal
    
    # Risk assessment
    current_portfolio_value: Decimal
    position_impact: Dict[str, Any]
    risk_violations: List[str]
    risk_warnings: List[str]
    
    # Limits checked
    limits_checked: List[str]
    limit_results: Dict[str, LimitCheckResult]
    
    # VaR analysis
    current_var: Optional[Decimal] = None
    incremental_var: Optional[Decimal] = None
    var_utilization: Optional[float] = None
    
    # Circuit breaker status
    circuit_breaker_status: Dict[str, Any] = field(default_factory=dict)
    
    # Decision metadata
    timestamp: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    processing_time_ms: float = 0.0
    confidence_score: float = 0.0
    
    # Recommendations
    recommended_actions: List[str] = field(default_factory=list)
    alternative_sizing: Optional[Dict[str, Decimal]] = None


@dataclass  
class PortfolioRiskSnapshot:
    """Real-time portfolio risk snapshot."""
    
    # Required fields (no defaults)
    timestamp: datetime
    portfolio_value: Decimal
    total_positions: int
    long_exposure: Decimal
    short_exposure: Decimal
    net_exposure: Decimal
    gross_exposure: Decimal
    unrealized_pnl: Decimal
    realized_pnl_today: Decimal
    daily_pnl: Decimal
    daily_pnl_pct: float
    current_drawdown: float
    max_drawdown: float
    volatility: float
    var_95_1day: Decimal
    var_99_1day: Decimal
    var_utilization_pct: float
    largest_position_pct: float
    top_5_concentration_pct: float
    circuit_breaker_status: str
    trading_allowed: bool
    
    # Optional fields (with defaults)
    sector_concentrations: Dict[str, float] = field(default_factory=dict)
    active_alerts: List[RiskAlert] = field(default_factory=list)
    breached_limits: List[str] = field(default_factory=list)


class LiveRiskMonitor:
    """
    Real-time risk monitoring system that integrates with trading engine
    for comprehensive risk management and order blocking.
    """
    
    def __init__(self, 
                 position_manager: UnifiedPositionManager,
                 risk_profile: RiskProfileType = RiskProfileType.PAPER_TRADING,
                 config: Optional[Dict[str, Any]] = None):
        """
        Initialize live risk monitor.
        
        Args:
            position_manager: Unified position manager for real-time position data
            risk_profile: Risk profile determining limit strictness  
            config: Risk monitoring configuration
        """
        self.position_manager = position_manager
        self.risk_profile = risk_profile
        self.config = config or {}
        
        # Initialize risk management components
        self.limit_checker = UnifiedLimitChecker(config or {})
        self.risk_metrics = RiskMetricsFacade(config or {})
        self.circuit_breaker = CircuitBreakerFacade(self._get_circuit_breaker_config())
        
        # Risk profile-specific limits
        self._setup_risk_limits()
        
        # Real-time state
        self.current_snapshot: Optional[PortfolioRiskSnapshot] = None
        self.last_var_calculation: Optional[datetime] = None
        self.cache = get_global_cache()
        
        # Event handlers and callbacks
        self.risk_decision_handlers: List[Callable[[RiskDecision], None]] = []
        self.portfolio_update_handlers: List[Callable[[PortfolioRiskSnapshot], None]] = []
        self.emergency_handlers: List[Callable[[str, Dict], None]] = []
        
        # Background monitoring
        self._monitoring_task: Optional[asyncio.Task] = None
        self._monitoring_interval = timedelta(seconds=self.config.get('monitoring_interval_seconds', 5))
        
        # Performance tracking
        self.decision_count = 0
        self.blocked_trades = 0
        self.avg_decision_time_ms = 0.0
        
        # Subscribe to position events
        self.position_manager.subscribe(PositionEventType.ALL, self._handle_position_event)
        
        # Register circuit breaker callback
        self.circuit_breaker.register_callback(self._handle_circuit_breaker_event)
        
        logger.info(f"LiveRiskMonitor initialized with {risk_profile.value} profile")
    
    def _get_circuit_breaker_config(self) -> Dict[str, Any]:
        """Get circuit breaker configuration based on risk profile."""
        
        base_config = {
            'volatility_threshold': 0.05,
            'max_drawdown': 0.08,
            'loss_rate_threshold': 0.03,
            'max_positions': 20,
            'max_position_size_pct': 0.10
        }
        
        # Adjust based on risk profile
        if self.risk_profile == RiskProfileType.PAPER_TRADING:
            base_config.update({
                'max_drawdown': 0.20,  # More lenient for paper trading
                'max_positions': 50,
                'max_position_size_pct': 0.20
            })
        elif self.risk_profile == RiskProfileType.CONSERVATIVE_LIVE:
            base_config.update({
                'max_drawdown': 0.05,  # Very strict
                'loss_rate_threshold': 0.02,
                'max_position_size_pct': 0.05
            })
        elif self.risk_profile == RiskProfileType.AGGRESSIVE_LIVE:
            base_config.update({
                'max_drawdown': 0.12,
                'max_position_size_pct': 0.15
            })
        
        return base_config
    
    def _setup_risk_limits(self):
        """Set up risk limits based on profile."""
        
        if self.risk_profile == RiskProfileType.PAPER_TRADING:
            limits = [
                LimitDefinition(
                    limit_id="paper_position_size",
                    name="Paper Trading Position Size",
                    description="Maximum position size for paper trading",
                    limit_type=LimitType.POSITION_SIZE,
                    scope=LimitScope.POSITION,
                    threshold_value=20.0,  # 20% of portfolio
                    operator=ComparisonOperator.LESS_EQUAL,
                    violation_action=LimitAction.ALERT,
                    scope_filter={'relative': True}
                ),
                LimitDefinition(
                    limit_id="paper_portfolio_var",
                    name="Paper Trading VaR Limit",
                    description="Portfolio VaR limit for paper trading",
                    limit_type=LimitType.VAR_UTILIZATION,
                    scope=LimitScope.GLOBAL,
                    threshold_value=0.10,  # 10% of portfolio
                    operator=ComparisonOperator.LESS_EQUAL,
                    violation_action=LimitAction.ALERT,
                    scope_filter={'metric_key': 'var_95'}
                )
            ]
        
        elif self.risk_profile == RiskProfileType.CONSERVATIVE_LIVE:
            limits = [
                LimitDefinition(
                    limit_id="conservative_position_size",
                    name="Conservative Position Size",
                    description="Maximum position size for conservative live trading",
                    limit_type=LimitType.POSITION_SIZE,
                    scope=LimitScope.POSITION,
                    threshold_value=5.0,  # 5% of portfolio
                    operator=ComparisonOperator.LESS_EQUAL,
                    violation_action=LimitAction.BLOCK_TRADE,
                    scope_filter={'relative': True}
                ),
                LimitDefinition(
                    limit_id="conservative_daily_loss",
                    name="Conservative Daily Loss Limit",
                    description="Maximum daily loss for conservative trading",
                    limit_type=LimitType.DRAWDOWN,
                    scope=LimitScope.GLOBAL,
                    threshold_value=0.02,  # 2% daily loss
                    operator=ComparisonOperator.LESS_EQUAL,
                    violation_action=LimitAction.PAUSE_STRATEGY,
                    scope_filter={'metric_key': 'daily_pnl_pct'}
                ),
                LimitDefinition(
                    limit_id="conservative_var_limit",
                    name="Conservative VaR Limit",
                    description="Portfolio VaR limit for conservative trading",
                    limit_type=LimitType.VAR_UTILIZATION,
                    scope=LimitScope.GLOBAL,
                    threshold_value=0.03,  # 3% of portfolio
                    operator=ComparisonOperator.LESS_EQUAL,
                    violation_action=LimitAction.REDUCE_POSITION,
                    scope_filter={'metric_key': 'var_95'}
                )
            ]
        
        else:  # MODERATE_LIVE or AGGRESSIVE_LIVE
            position_limit = 10.0 if self.risk_profile == RiskProfileType.MODERATE_LIVE else 15.0
            var_limit = 0.05 if self.risk_profile == RiskProfileType.MODERATE_LIVE else 0.08
            
            limits = [
                LimitDefinition(
                    limit_id="live_position_size",
                    name="Live Trading Position Size",
                    description="Maximum position size for live trading",
                    limit_type=LimitType.POSITION_SIZE,
                    scope=LimitScope.POSITION,
                    threshold_value=position_limit,
                    operator=ComparisonOperator.LESS_EQUAL,
                    violation_action=LimitAction.BLOCK_TRADE,
                    scope_filter={'relative': True}
                ),
                LimitDefinition(
                    limit_id="live_var_limit",
                    name="Live Trading VaR Limit",
                    description="Portfolio VaR limit for live trading",
                    limit_type=LimitType.VAR_UTILIZATION,
                    scope=LimitScope.GLOBAL,
                    threshold_value=var_limit,
                    operator=ComparisonOperator.LESS_EQUAL,
                    violation_action=LimitAction.BLOCK_TRADE,
                    scope_filter={'metric_key': 'var_95'}
                )
            ]
        
        # Add all limits to checker
        for limit in limits:
            self.limit_checker.add_limit(limit)
    
    async def start_monitoring(self):
        """Start real-time risk monitoring."""
        if self._monitoring_task is None or self._monitoring_task.done():
            self._monitoring_task = asyncio.create_task(self._monitoring_loop())
            logger.info("Real-time risk monitoring started")
    
    async def stop_monitoring(self):
        """Stop real-time risk monitoring."""
        if self._monitoring_task:
            self._monitoring_task.cancel()
            try:
                await self._monitoring_task
            except asyncio.CancelledError:
                pass
            logger.info("Real-time risk monitoring stopped")
    
    async def evaluate_trade_risk(self, 
                                 symbol: str,
                                 side: OrderSide,
                                 quantity: Union[float, Decimal],
                                 price: Union[float, Decimal]) -> RiskDecision:
        """
        Comprehensive pre-trade risk evaluation with decision.
        
        This is the main entry point for trade risk evaluation that should
        be called before any order execution.
        """
        start_time = datetime.now()
        quantity = Decimal(str(quantity))
        price = Decimal(str(price))
        
        # Generate decision ID
        decision_id = f"risk_{symbol}_{int(start_time.timestamp() * 1000)}"
        
        # Get current portfolio state
        await self._update_portfolio_snapshot()
        current_portfolio_value = await self.position_manager.get_portfolio_value()
        
        # Initialize decision
        decision = RiskDecision(
            decision_id=decision_id,
            decision_type=RiskDecisionType.ALLOW_TRADE,
            allowed=True,
            symbol=symbol,
            side=side,
            quantity=quantity,
            price=price,
            current_portfolio_value=current_portfolio_value,
            position_impact={},
            risk_violations=[],
            risk_warnings=[],
            limits_checked=[],
            limit_results={}
        )
        
        try:
            # 1. Circuit breaker check
            if not self.circuit_breaker.is_trading_allowed():
                decision.decision_type = RiskDecisionType.EMERGENCY_HALT
                decision.allowed = False
                decision.risk_violations.append("Circuit breaker is tripped")
                decision.circuit_breaker_status = self.circuit_breaker.get_breaker_status()
                return decision
            
            # 2. Calculate position impact
            position_value = quantity * price
            position_impact = await self._calculate_position_impact(
                symbol, side, quantity, price, current_portfolio_value
            )
            decision.position_impact = position_impact
            
            # 3. Check position limits
            limit_results = await self._check_position_limits(
                symbol, side, quantity, price, current_portfolio_value
            )
            decision.limit_results.update(limit_results)
            decision.limits_checked.extend(limit_results.keys())
            
            # Check for violations
            violations = [lid for lid, result in limit_results.items() if not result.passed]
            if violations:
                decision.risk_violations.extend([f"Limit violation: {lid}" for lid in violations])
                
                # Determine action based on most severe violation
                severest_action = self._get_severest_action(limit_results)
                if severest_action in [LimitAction.BLOCK_TRADE, LimitAction.EMERGENCY_STOP]:
                    decision.decision_type = RiskDecisionType.BLOCK_TRADE
                    decision.allowed = False
            
            # 4. VaR-based analysis
            var_analysis = await self._perform_var_analysis(symbol, side, quantity, price)
            if var_analysis:
                decision.current_var = var_analysis.get('current_var')
                decision.incremental_var = var_analysis.get('incremental_var')
                decision.var_utilization = var_analysis.get('utilization_pct')
                
                # Check VaR limits
                if var_analysis.get('exceeds_limit', False):
                    decision.risk_violations.append(f"VaR limit exceeded: {var_analysis.get('message', '')}")
                    if self.risk_profile != RiskProfileType.PAPER_TRADING:
                        decision.decision_type = RiskDecisionType.BLOCK_TRADE
                        decision.allowed = False
            
            # 5. Concentration risk check
            concentration_check = await self._check_concentration_risk(
                symbol, side, quantity, price, current_portfolio_value
            )
            if not concentration_check['passed']:
                decision.risk_warnings.extend(concentration_check.get('warnings', []))
                if concentration_check.get('critical', False):
                    decision.risk_violations.append("Critical concentration risk")
                    decision.decision_type = RiskDecisionType.BLOCK_TRADE
                    decision.allowed = False
            
            # 6. Generate recommendations
            decision.recommended_actions = self._generate_recommendations(decision)
            
            # 7. Alternative sizing if blocked
            if not decision.allowed:
                alternative = await self._calculate_alternative_sizing(
                    symbol, side, quantity, price, current_portfolio_value
                )
                decision.alternative_sizing = alternative
            
            # 8. Calculate confidence score
            decision.confidence_score = self._calculate_confidence_score(decision)
            
        except Exception as e:
            logger.error(f"Error in risk evaluation: {e}", exc_info=True)
            decision.decision_type = RiskDecisionType.BLOCK_TRADE
            decision.allowed = False
            decision.risk_violations.append(f"Risk evaluation error: {str(e)}")
        
        finally:
            # Update performance metrics
            processing_time = (datetime.now() - start_time).total_seconds() * 1000
            decision.processing_time_ms = processing_time
            
            self.decision_count += 1
            if not decision.allowed:
                self.blocked_trades += 1
            
            # Update average decision time
            self.avg_decision_time_ms = (
                (self.avg_decision_time_ms * (self.decision_count - 1) + processing_time) 
                / self.decision_count
            )
            
            # Emit decision to handlers
            for handler in self.risk_decision_handlers:
                try:
                    handler(decision)
                except Exception as e:
                    logger.error(f"Error in risk decision handler: {e}")
            
            # Log decision
            self._log_risk_decision(decision)
        
        return decision
    
    async def _calculate_position_impact(self, 
                                       symbol: str,
                                       side: OrderSide,
                                       quantity: Decimal,
                                       price: Decimal,
                                       portfolio_value: Decimal) -> Dict[str, Any]:
        """Calculate the impact of a position on portfolio metrics."""
        
        current_position = self.position_manager.get_position(symbol)
        position_value = quantity * price
        
        impact = {
            'position_value': position_value,
            'portfolio_weight_change': float(position_value / portfolio_value) if portfolio_value > 0 else 0,
            'is_new_position': current_position is None,
            'is_increase': False,
            'is_decrease': False,
            'is_reversal': False
        }
        
        if current_position:
            if side == OrderSide.BUY:
                if current_position.side.value == 'long':
                    impact['is_increase'] = True
                elif current_position.side.value == 'short':
                    impact['is_reversal'] = True
            else:  # SELL
                if current_position.side.value == 'long':
                    if quantity <= current_position.abs_quantity:
                        impact['is_decrease'] = True
                    else:
                        impact['is_reversal'] = True
                elif current_position.side.value == 'short':
                    impact['is_increase'] = True
        
        return impact
    
    async def _check_position_limits(self,
                                   symbol: str,
                                   side: OrderSide,
                                   quantity: Decimal,
                                   price: Decimal,
                                   portfolio_value: Decimal) -> Dict[str, LimitCheckResult]:
        """Check position-related limits."""
        
        results = {}
        position_value = float(quantity * price)
        
        # Get context for limit checking
        context = {
            'symbol': symbol,
            'side': side.value,
            'portfolio_value': float(portfolio_value),
            'position_value': position_value
        }
        
        # Check all position limits
        position_limit_results = self.limit_checker.check_position_limits(
            position_id=symbol,
            position_value=position_value,
            portfolio_value=float(portfolio_value)
        )
        
        for result in position_limit_results:
            results[result.limit_id] = result
        
        return results
    
    async def _perform_var_analysis(self,
                                  symbol: str,
                                  side: OrderSide,
                                  quantity: Decimal,
                                  price: Decimal) -> Optional[Dict[str, Any]]:
        """Perform VaR analysis for the proposed trade."""
        
        try:
            # Get portfolio returns for VaR calculation
            # This would need historical return data - placeholder for now
            portfolio_returns = secure_numpy_normal(0, 0.02, 252)  # Placeholder
            
            # Calculate current portfolio VaR
            current_var_result = self.risk_metrics.calculate_portfolio_var(
                returns=portfolio_returns,
                confidence_level=0.95
            )
            
            # For incremental VaR, we'd need to simulate the impact
            # This is a simplified calculation
            position_value = float(quantity * price)
            portfolio_value = float(await self.position_manager.get_portfolio_value())
            
            if portfolio_value > 0:
                position_weight = position_value / portfolio_value
                # Approximate incremental VaR as position weight * portfolio VaR
                incremental_var = position_weight * current_var_result.var_value * portfolio_value
                
                total_var = current_var_result.var_value * portfolio_value + incremental_var
                var_utilization = total_var / portfolio_value
                
                # Check against limits
                var_limit = 0.05  # 5% default limit
                if self.risk_profile == RiskProfileType.CONSERVATIVE_LIVE:
                    var_limit = 0.03
                elif self.risk_profile == RiskProfileType.AGGRESSIVE_LIVE:
                    var_limit = 0.08
                
                return {
                    'current_var': Decimal(str(current_var_result.var_value * portfolio_value)),
                    'incremental_var': Decimal(str(incremental_var)),
                    'total_var': Decimal(str(total_var)),
                    'utilization_pct': var_utilization * 100,
                    'limit_pct': var_limit * 100,
                    'exceeds_limit': var_utilization > var_limit,
                    'message': f"VaR utilization {var_utilization:.2%} vs limit {var_limit:.2%}"
                }
        
        except Exception as e:
            logger.warning(f"VaR analysis failed: {e}")
            return None
    
    async def _check_concentration_risk(self,
                                      symbol: str,
                                      side: OrderSide,
                                      quantity: Decimal,
                                      price: Decimal,
                                      portfolio_value: Decimal) -> Dict[str, Any]:
        """Check concentration risk limits."""
        
        position_value = quantity * price
        concentration_pct = float(position_value / portfolio_value) if portfolio_value > 0 else 0
        
        # Define concentration limits based on risk profile
        warning_threshold = 0.15  # 15%
        critical_threshold = 0.25  # 25%
        
        if self.risk_profile == RiskProfileType.CONSERVATIVE_LIVE:
            warning_threshold = 0.10
            critical_threshold = 0.15
        elif self.risk_profile == RiskProfileType.AGGRESSIVE_LIVE:
            warning_threshold = 0.20
            critical_threshold = 0.30
        
        warnings = []
        critical = False
        
        if concentration_pct > critical_threshold:
            warnings.append(f"Critical position concentration: {concentration_pct:.1%}")
            critical = True
        elif concentration_pct > warning_threshold:
            warnings.append(f"High position concentration: {concentration_pct:.1%}")
        
        return {
            'passed': not critical,
            'concentration_pct': concentration_pct,
            'warnings': warnings,
            'critical': critical
        }
    
    def _get_severest_action(self, limit_results: Dict[str, LimitCheckResult]) -> LimitAction:
        """Get the most severe action from limit check results."""
        
        action_severity = {
            LimitAction.LOG_ONLY: 1,
            LimitAction.ALERT: 2,
            LimitAction.REDUCE_POSITION: 3,
            LimitAction.BLOCK_TRADE: 4,
            LimitAction.PAUSE_STRATEGY: 5,
            LimitAction.LIQUIDATE: 6,
            LimitAction.EMERGENCY_STOP: 7
        }
        
        severest_action = LimitAction.LOG_ONLY
        max_severity = 0
        
        for result in limit_results.values():
            if result.violation and result.violation.recommended_action:
                severity = action_severity.get(result.violation.recommended_action, 0)
                if severity > max_severity:
                    max_severity = severity
                    severest_action = result.violation.recommended_action
        
        return severest_action
    
    def _generate_recommendations(self, decision: RiskDecision) -> List[str]:
        """Generate actionable recommendations based on risk decision."""
        
        recommendations = []
        
        if not decision.allowed:
            recommendations.append("Trade blocked due to risk violations")
            
            if decision.alternative_sizing:
                recommendations.append(f"Consider alternative position size: {decision.alternative_sizing}")
            
            if decision.current_var and decision.var_utilization and decision.var_utilization > 80:
                recommendations.append("High VaR utilization - consider reducing overall portfolio risk")
            
            if any("concentration" in violation.lower() for violation in decision.risk_violations):
                recommendations.append("Reduce position size or diversify across more symbols")
        
        else:
            if decision.risk_warnings:
                recommendations.append("Monitor position closely due to risk warnings")
            
            if decision.var_utilization and decision.var_utilization > 60:
                recommendations.append("Approaching VaR limits - consider position sizing")
        
        return recommendations
    
    async def _calculate_alternative_sizing(self,
                                          symbol: str,
                                          side: OrderSide,
                                          quantity: Decimal,
                                          price: Decimal,
                                          portfolio_value: Decimal) -> Optional[Dict[str, Decimal]]:
        """Calculate alternative position sizing that would pass risk checks."""
        
        # Start with 50% of original size and test
        for reduction_factor in [0.5, 0.3, 0.1, 0.05]:
            alt_quantity = quantity * Decimal(str(reduction_factor))
            
            if alt_quantity < Decimal('0.01'):  # Minimum meaningful quantity
                break
            
            # Quick check if this would pass
            alt_position_value = alt_quantity * price
            alt_concentration = float(alt_position_value / portfolio_value) if portfolio_value > 0 else 0
            
            # Simple check against concentration limits
            if alt_concentration < 0.10:  # Conservative limit
                return {
                    'quantity': alt_quantity,
                    'value': alt_position_value,
                    'concentration_pct': Decimal(str(alt_concentration * 100)),
                    'reduction_factor': Decimal(str(reduction_factor))
                }
        
        return None
    
    def _calculate_confidence_score(self, decision: RiskDecision) -> float:
        """Calculate confidence score for the risk decision."""
        
        score = 100.0
        
        # Reduce score for violations
        score -= len(decision.risk_violations) * 20
        score -= len(decision.risk_warnings) * 5
        
        # Reduce score for high processing time
        if decision.processing_time_ms > 100:
            score -= min(20, (decision.processing_time_ms - 100) / 10)
        
        # Adjust for VaR utilization
        if decision.var_utilization:
            if decision.var_utilization > 80:
                score -= 15
            elif decision.var_utilization > 60:
                score -= 5
        
        return max(0.0, min(100.0, score))
    
    def _log_risk_decision(self, decision: RiskDecision):
        """Log risk decision with appropriate level."""
        
        if not decision.allowed:
            logger.warning(
                f"TRADE BLOCKED: {decision.symbol} {decision.side.value} {decision.quantity} @ {decision.price} | "
                f"Violations: {decision.risk_violations} | "
                f"Decision ID: {decision.decision_id}"
            )
        elif decision.risk_warnings:
            logger.info(
                f"TRADE ALLOWED (with warnings): {decision.symbol} {decision.side.value} {decision.quantity} @ {decision.price} | "
                f"Warnings: {decision.risk_warnings} | "
                f"Decision ID: {decision.decision_id}"
            )
        else:
            logger.debug(
                f"TRADE ALLOWED: {decision.symbol} {decision.side.value} {decision.quantity} @ {decision.price} | "
                f"Decision ID: {decision.decision_id} | "
                f"Processing time: {decision.processing_time_ms:.1f}ms"
            )
    
    async def _monitoring_loop(self):
        """Background monitoring loop for real-time risk tracking."""
        
        while True:
            try:
                await self._update_portfolio_snapshot()
                await asyncio.sleep(self._monitoring_interval.total_seconds())
                
            except asyncio.CancelledError:
                logger.info("Risk monitoring loop cancelled")
                break
            except Exception as e:
                logger.error(f"Error in risk monitoring loop: {e}", exc_info=True)
                await asyncio.sleep(30)  # Longer delay on error
    
    async def _update_portfolio_snapshot(self):
        """Update real-time portfolio risk snapshot."""
        
        try:
            # Get current portfolio data
            portfolio_value = await self.position_manager.get_portfolio_value()
            positions = self.position_manager.get_all_positions()
            unrealized_pnl = await self.position_manager.get_total_unrealized_pnl()
            realized_pnl_today = self.position_manager.get_realized_pnl_today()
            
            # Calculate exposure metrics
            long_exposure = sum(pos.market_value for pos in positions.values() 
                              if pos.side.value == 'long')
            short_exposure = sum(abs(pos.market_value) for pos in positions.values() 
                               if pos.side.value == 'short')
            net_exposure = long_exposure - short_exposure
            gross_exposure = long_exposure + short_exposure
            
            # Calculate concentration
            position_values = [abs(pos.market_value) for pos in positions.values()]
            largest_position_pct = (max(position_values) / portfolio_value * 100 
                                  if position_values and portfolio_value > 0 else 0)
            
            sorted_values = sorted(position_values, reverse=True)
            top_5_concentration_pct = (sum(sorted_values[:5]) / portfolio_value * 100 
                                     if len(sorted_values) >= 5 and portfolio_value > 0 
                                     else sum(sorted_values) / portfolio_value * 100 
                                     if sorted_values and portfolio_value > 0 else 0)
            
            # Create snapshot
            snapshot = PortfolioRiskSnapshot(
                timestamp=datetime.now(timezone.utc),
                portfolio_value=portfolio_value,
                total_positions=len(positions),
                long_exposure=Decimal(str(long_exposure)),
                short_exposure=Decimal(str(short_exposure)),
                net_exposure=Decimal(str(net_exposure)),
                gross_exposure=Decimal(str(gross_exposure)),
                unrealized_pnl=unrealized_pnl,
                realized_pnl_today=realized_pnl_today,
                daily_pnl=unrealized_pnl + realized_pnl_today,
                daily_pnl_pct=float((unrealized_pnl + realized_pnl_today) / portfolio_value * 100) 
                             if portfolio_value > 0 else 0,
                current_drawdown=0.0,  # Would need historical data
                max_drawdown=0.0,      # Would need historical data
                volatility=0.0,        # Would need historical data
                var_95_1day=Decimal('0'),  # Would need VaR calculation
                var_99_1day=Decimal('0'),  # Would need VaR calculation
                var_utilization_pct=0.0,
                largest_position_pct=largest_position_pct,
                top_5_concentration_pct=top_5_concentration_pct,
                circuit_breaker_status=self.circuit_breaker.get_breaker_status()['breaker_states'],
                trading_allowed=self.circuit_breaker.is_trading_allowed()
            )
            
            self.current_snapshot = snapshot
            
            # Emit to handlers
            for handler in self.portfolio_update_handlers:
                try:
                    handler(snapshot)
                except Exception as e:
                    logger.error(f"Error in portfolio update handler: {e}")
        
        except Exception as e:
            logger.error(f"Error updating portfolio snapshot: {e}", exc_info=True)
    
    async def _handle_position_event(self, event: PositionEvent):
        """Handle position events for real-time monitoring."""
        
        # Update snapshot on significant position changes
        if event.event_type in [
            PositionEventType.POSITION_OPENED,
            PositionEventType.POSITION_CLOSED,
            PositionEventType.FILL_PROCESSED
        ]:
            await self._update_portfolio_snapshot()
    
    async def _handle_circuit_breaker_event(self, event: BreakerEvent):
        """Handle circuit breaker events."""
        
        logger.critical(f"Circuit breaker event: {event.breaker_type.value} - {event.message}")
        
        # Emit emergency alert
        for handler in self.emergency_handlers:
            try:
                handler(f"Circuit breaker {event.breaker_type.value}", {
                    'event': event,
                    'portfolio_snapshot': self.current_snapshot
                })
            except Exception as e:
                logger.error(f"Error in emergency handler: {e}")
    
    # Public API methods
    
    def add_risk_decision_handler(self, handler: Callable[[RiskDecision], None]):
        """Add handler for risk decisions."""
        self.risk_decision_handlers.append(handler)
    
    def add_portfolio_update_handler(self, handler: Callable[[PortfolioRiskSnapshot], None]):
        """Add handler for portfolio updates."""
        self.portfolio_update_handlers.append(handler)
    
    def add_emergency_handler(self, handler: Callable[[str, Dict], None]):
        """Add handler for emergency events."""
        self.emergency_handlers.append(handler)
    
    def get_current_snapshot(self) -> Optional[PortfolioRiskSnapshot]:
        """Get current portfolio risk snapshot."""
        return self.current_snapshot
    
    def get_risk_statistics(self) -> Dict[str, Any]:
        """Get risk monitoring statistics."""
        
        return {
            'total_decisions': self.decision_count,
            'blocked_trades': self.blocked_trades,
            'block_rate_pct': (self.blocked_trades / self.decision_count * 100) 
                             if self.decision_count > 0 else 0,
            'avg_decision_time_ms': self.avg_decision_time_ms,
            'risk_profile': self.risk_profile.value,
            'monitoring_active': self._monitoring_task is not None and not self._monitoring_task.done(),
            'last_snapshot_time': self.current_snapshot.timestamp.isoformat() 
                                if self.current_snapshot else None
        }
    
    async def force_risk_refresh(self):
        """Force immediate risk assessment refresh."""
        await self._update_portfolio_snapshot()
        logger.info("Forced risk assessment refresh completed")